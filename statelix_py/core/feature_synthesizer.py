"""
Feature Synthesizer: Automatic Feature Generation on Geometric Space

This module generates features mathematically by:
1. Projecting onto orthogonal complement spaces
2. Detecting topological holes and adding corresponding directions
3. Automatic polynomial basis expansion
"""

import numpy as np
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass

# Import from unified space
try:
    from .unified_space import CausalSpace, TopologicalHole, PersistenceDiagram
except ImportError:
    from unified_space import CausalSpace, TopologicalHole, PersistenceDiagram


@dataclass
class SynthesizedFeature:
    """A newly generated feature with metadata."""
    name: str
    values: np.ndarray
    source_type: str  # 'orthogonal', 'topological', 'polynomial', 'interaction'
    confidence: float  # How important this feature likely is
    parent_features: List[str] = None
    
    def __post_init__(self):
        if self.parent_features is None:
            self.parent_features = []


class FeatureSynthesizer:
    """
    Automatic feature synthesis using geometric-topological methods.
    
    Features are treated as vectors in a high-dimensional geometric space.
    New features are generated by:
    1. Finding orthogonal directions (unexplained variance)
    2. Filling topological holes (missing structure)
    3. Polynomial expansion (nonlinear relationships)
    """
    
    def __init__(
        self,
        max_polynomial_degree: int = 2,
        max_interactions: int = 10,
        orthogonal_threshold: float = 0.1,
        topological_threshold: float = 0.1
    ):
        """
        Initialize the synthesizer.
        
        Args:
            max_polynomial_degree: Maximum degree for polynomial features
            max_interactions: Maximum number of interaction terms to generate
            orthogonal_threshold: Minimum eigenvalue ratio for orthogonal features
            topological_threshold: Minimum persistence for topological features
        """
        self.max_polynomial_degree = max_polynomial_degree
        self.max_interactions = max_interactions
        self.orthogonal_threshold = orthogonal_threshold
        self.topological_threshold = topological_threshold
    
    def synthesize(
        self,
        X: np.ndarray,
        y: Optional[np.ndarray] = None,
        causal_space: Optional[CausalSpace] = None,
        feature_names: Optional[List[str]] = None
    ) -> Tuple[np.ndarray, List[SynthesizedFeature]]:
        """
        Generate new features from existing data.
        
        Args:
            X: (n_samples, n_features) feature matrix
            y: Optional target variable for supervised synthesis
            causal_space: Optional CausalSpace for topological analysis
            feature_names: Optional names for original features
        
        Returns:
            Tuple of (augmented X, list of synthesized features)
        """
        n_samples, n_features = X.shape
        feature_names = feature_names or [f"x{i}" for i in range(n_features)]
        
        synthesized = []
        
        # 1. Orthogonal complement features
        orth_features = self._generate_orthogonal_features(X, y, feature_names)
        synthesized.extend(orth_features)
        
        # 2. Topological hole features
        if causal_space is not None:
            topo_features = self._generate_topological_features(X, causal_space, feature_names)
            synthesized.extend(topo_features)
        
        # 3. Polynomial features
        poly_features = self._generate_polynomial_features(X, feature_names)
        synthesized.extend(poly_features)
        
        # 4. Interaction features (if y is provided for selection)
        if y is not None:
            interaction_features = self._generate_interaction_features(X, y, feature_names)
            synthesized.extend(interaction_features)
        
        # Build augmented matrix
        if synthesized:
            new_columns = np.column_stack([f.values for f in synthesized])
            X_augmented = np.hstack([X, new_columns])
        else:
            X_augmented = X
        
        return X_augmented, synthesized
    
    def _generate_orthogonal_features(
        self,
        X: np.ndarray,
        y: Optional[np.ndarray],
        feature_names: List[str]
    ) -> List[SynthesizedFeature]:
        """
        Generate features from orthogonal complement of current space.
        
        Uses residuals from y ~ X as potential new feature directions.
        """
        features = []
        
        if y is None:
            return features
        
        n_samples = X.shape[0]
        
        # Compute residuals
        try:
            # OLS residuals: e = y - X(X'X)^{-1}X'y
            X_pinv = np.linalg.pinv(X)
            beta = X_pinv @ y
            y_hat = X @ beta
            residuals = y - y_hat
            
            # If residuals have significant variance, they represent unexplained direction
            residual_var = np.var(residuals)
            total_var = np.var(y)
            
            if residual_var / total_var > self.orthogonal_threshold:
                # Normalize residuals as a feature
                normalized_residuals = (residuals - residuals.mean()) / (residuals.std() + 1e-8)
                
                features.append(SynthesizedFeature(
                    name="orthogonal_residual",
                    values=normalized_residuals,
                    source_type="orthogonal",
                    confidence=residual_var / total_var
                ))
        except np.linalg.LinAlgError:
            pass
        
        return features
    
    def _generate_topological_features(
        self,
        X: np.ndarray,
        causal_space: CausalSpace,
        feature_names: List[str]
    ) -> List[SynthesizedFeature]:
        """
        Generate features that fill topological holes.
        
        For each significant hole in the persistence diagram,
        generate a feature pointing in that direction.
        """
        features = []
        
        holes = causal_space.detect_topological_holes(self.topological_threshold)
        
        for i, hole in enumerate(holes):
            if hole.direction is not None and np.linalg.norm(hole.direction) > 1e-8:
                # Project X onto hole direction
                direction = hole.direction / np.linalg.norm(hole.direction)
                
                # Pad direction to match X dimensions
                if len(direction) < X.shape[1]:
                    direction = np.pad(direction, (0, X.shape[1] - len(direction)))
                elif len(direction) > X.shape[1]:
                    direction = direction[:X.shape[1]]
                
                projection = X @ direction
                
                features.append(SynthesizedFeature(
                    name=f"topo_hole_{i}_H{hole.dimension}",
                    values=projection,
                    source_type="topological",
                    confidence=hole.persistence
                ))
        
        return features
    
    def _generate_polynomial_features(
        self,
        X: np.ndarray,
        feature_names: List[str]
    ) -> List[SynthesizedFeature]:
        """
        Generate polynomial features (squared terms).
        """
        features = []
        n_features = X.shape[1]
        
        for degree in range(2, self.max_polynomial_degree + 1):
            for i in range(n_features):
                powered = X[:, i] ** degree
                
                # Skip if too correlated with original
                if np.abs(np.corrcoef(X[:, i], powered)[0, 1]) < 0.95:
                    features.append(SynthesizedFeature(
                        name=f"{feature_names[i]}^{degree}",
                        values=powered,
                        source_type="polynomial",
                        confidence=0.5,
                        parent_features=[feature_names[i]]
                    ))
        
        return features
    
    def _generate_interaction_features(
        self,
        X: np.ndarray,
        y: np.ndarray,
        feature_names: List[str]
    ) -> List[SynthesizedFeature]:
        """
        Generate interaction features based on correlation with y.
        """
        features = []
        n_features = X.shape[1]
        
        # Score all possible interactions
        interaction_scores = []
        
        for i in range(n_features):
            for j in range(i + 1, n_features):
                interaction = X[:, i] * X[:, j]
                
                # Score by correlation with y
                corr = np.abs(np.corrcoef(interaction, y)[0, 1])
                if not np.isnan(corr):
                    interaction_scores.append((corr, i, j, interaction))
        
        # Take top interactions
        interaction_scores.sort(reverse=True)
        
        for score, i, j, interaction in interaction_scores[:self.max_interactions]:
            if score > 0.1:  # Minimum correlation threshold
                features.append(SynthesizedFeature(
                    name=f"{feature_names[i]}*{feature_names[j]}",
                    values=interaction,
                    source_type="interaction",
                    confidence=score,
                    parent_features=[feature_names[i], feature_names[j]]
                ))
        
        return features
    
    def suggest_features(
        self,
        X: np.ndarray,
        y: Optional[np.ndarray] = None,
        causal_space: Optional[CausalSpace] = None,
        feature_names: Optional[List[str]] = None,
        top_k: int = 5
    ) -> List[Dict[str, Any]]:
        """
        Suggest the most impactful features to add.
        
        Returns a list of suggestions without actually generating the features.
        """
        _, synthesized = self.synthesize(X, y, causal_space, feature_names)
        
        # Sort by confidence
        synthesized.sort(key=lambda f: f.confidence, reverse=True)
        
        suggestions = []
        for f in synthesized[:top_k]:
            suggestions.append({
                'name': f.name,
                'type': f.source_type,
                'confidence': f.confidence,
                'parents': f.parent_features,
                'explanation': self._explain_feature(f)
            })
        
        return suggestions
    
    def _explain_feature(self, feature: SynthesizedFeature) -> str:
        """Generate human-readable explanation for a synthesized feature."""
        if feature.source_type == 'orthogonal':
            return "Captures unexplained variance direction in the target"
        elif feature.source_type == 'topological':
            return f"Fills a topological hole in the data structure"
        elif feature.source_type == 'polynomial':
            return f"Nonlinear effect of {feature.parent_features[0]}"
        elif feature.source_type == 'interaction':
            return f"Interaction effect between {feature.parent_features[0]} and {feature.parent_features[1]}"
        return "Unknown source"
